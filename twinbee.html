<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>キャラクター作成</title>
    <link type="text/css" rel="stylesheet" href="./css/twinbee.css" />
  </head>
  <body>
    <div class="total">
      <div class="bullet"></div>
      <div class="leftArm"></div>
      <div class="rightArm"></div>
      <div class="leftHand"></div>
      <div class="rightHand"></div>
      <div class="body">
        <div class="eye"></div>
        <div class="leftLeg"></div>
        <div class="tail"></div>
        <div class="rightLeg"></div>
      </div>
    </div>
    <div class="boss">
      <div class="item1"></div>
      <div class="item2"></div>
      <div class="item3"></div>
      <div class="item4"></div>
      <div class="item5"></div>
      <div class="item6"></div>
    </div>
    <div class="field"></div>
    <script type="module">
      import { Twinbee } from "./class/twinbee.js";
      import { Key } from "./class/key.js";
      import { Bullet } from "./class/bullet.js";
      import { CollisionDetection } from "./class/collisionDetection.js";
      import { Enemy } from "./class/enemy.js";
      import { flash } from "./js/animation.js";

      // ### 変数定義 ###
      const charElement = document.getElementsByClassName("total")[0];
      const bulletElement = document.getElementsByClassName("bullet")[0];
      const fieldElement = document.getElementsByClassName("field")[0];
      const bossElement = document.getElementsByClassName("boss")[0];
      const item1Element = document.getElementsByClassName("item1")[0];
      const item2Element = document.getElementsByClassName("item2")[0];
      const item3Element = document.getElementsByClassName("item3")[0];
      const item4Element = document.getElementsByClassName("item4")[0];
      const item5Element = document.getElementsByClassName("item5")[0];
      const item6Element = document.getElementsByClassName("item6")[0];
      // 移動判定用のフィールド座標系
      const fieldCoordinate = fieldElement.getBoundingClientRect();
      let isAttack = 0;
      // ボスの行動パターン
      let bossActionPattern = 0;
      let beforeBossActionPattern = 0;
      // ボスが移動中かどうか判定
      let isBossMoving = false;
      // 当たり判定ディレイ
      const delay = 500;
      // フラッシュアニメーション中かどうか判断するようの要素
      let twinbeeFlushElement = charElement.animate(
        flash.process,
        flash.setting
      );
      let bossFlushElement = bossElement.animate(flash.process, flash.setting);
      let item1FlushElement = item1Element.animate(
        flash.process,
        flash.setting
      );
      let item2FlushElement = item2Element.animate(
        flash.process,
        flash.setting
      );
      let item3FlushElement = item3Element.animate(
        flash.process,
        flash.setting
      );
      let item4FlushElement = item4Element.animate(
        flash.process,
        flash.setting
      );
      let item5FlushElement = item5Element.animate(
        flash.process,
        flash.setting
      );
      let item6FlushElement = item6Element.animate(
        flash.process,
        flash.setting
      );

      // ### インスタンス生成 ###
      // 各キャラクターインスタンス
      const twinbee = new Twinbee();
      const key = new Key();
      const bullet = new Bullet();
      const boss = new Enemy(20, 30, 1);
      const item1 = new Enemy(10, 0, 1);
      const item2 = new Enemy(10, 0, 1);
      const item3 = new Enemy(10, 0, 1);
      const item4 = new Enemy(10, 0, 1);
      const item5 = new Enemy(10, 0, 1);
      const item6 = new Enemy(10, 0, 1);
      // 当たり判定用インスタンス
      const collisionBullet = new CollisionDetection(
        bulletElement.clientWidth / 2
      );
      const collisionBoss = new CollisionDetection(bossElement.clientWidth / 2);
      const collisionTwinbee = new CollisionDetection(
        charElement.clientWidth / 2
      );
      const collisionItem1 = new CollisionDetection(
        item1Element.clientWidth / 2
      );
      const collisionItem2 = new CollisionDetection(
        item2Element.clientWidth / 2
      );
      const collisionItem3 = new CollisionDetection(
        item3Element.clientWidth / 2
      );
      const collisionItem4 = new CollisionDetection(
        item4Element.clientWidth / 2
      );
      const collisionItem5 = new CollisionDetection(
        item5Element.clientWidth / 2
      );
      const collisionItem6 = new CollisionDetection(
        item6Element.clientWidth / 2
      );

      // ### キー押下処理 ###
      document.addEventListener("keydown", (e) => {
        // 左右キー押下時処理
        if (key.isMoveX(e.key)) {
          twinbee.setDirectionX(key.whichMoveX(e.key));
        }
        // 上下キー押下時処理
        if (key.isMoveY(e.key)) {
          twinbee.setDirectionY(key.whichMoveY(e.key));
        }
        // a(攻撃)キー押下時処理
        if (key.isAttack(e.key)) {
          Object.assign(bulletElement.style, {
            display: "",
          });
          isAttack = 1;
        }
      });

      // ### キー離した処理 ###
      document.addEventListener("keyup", (e) => {
        // 左右キー離したとき処理
        if (twinbee.getDirectionX() === key.whichMoveX(e.key)) {
          twinbee.initDirectionX();
        }
        // 上下キー離したとき処理
        if (twinbee.getDirectionY() === key.whichMoveY(e.key)) {
          twinbee.initDirectionY();
        }
        // a(攻撃)キー離したとき処理
        if (key.isAttack(e.key)) {
          Object.assign(bulletElement.style, {
            display: "none",
          });
          isAttack = 0;
        }
      });

      // ### ツインビー移動の処理 ###
      (function twinbeeMoveAnimation() {
        // スクロールしない範囲での移動に限定させる
        // 後々は移動できる範囲をボックス内に限定させる
        if (twinbee.canMove(fieldCoordinate)) {
          twinbee.move(charElement);
        }

        requestAnimationFrame(twinbeeMoveAnimation);
      })();

      // ### 弾の移動処理 ###
      (function bulletMoveAnimation() {
        bullet.move(bulletElement, isAttack);
        bullet.initPositionWhenOverField(bulletElement);

        requestAnimationFrame(bulletMoveAnimation);
      })();

      // ### 敵を対象とした当たり判定を常時計算 ###
      (function hit() {
        // 当たり判定算出対象の座標を再計算
        const localBulletElement = document.getElementsByClassName("bullet")[0];
        const localBossElement = document.getElementsByClassName("boss")[0];
        const localCharactorElement =
          document.getElementsByClassName("total")[0];
        const localItem1Element = document.getElementsByClassName("item1")[0];
        const localItem2Element = document.getElementsByClassName("item2")[0];
        const localItem3Element = document.getElementsByClassName("item3")[0];
        const localItem4Element = document.getElementsByClassName("item4")[0];
        const localItem5Element = document.getElementsByClassName("item5")[0];
        const localItem6Element = document.getElementsByClassName("item6")[0];

        // 弾の中心座標を算出、設定
        const bulletCoordinate = localBulletElement.getBoundingClientRect();
        collisionBullet.calcCenter(bulletCoordinate);

        // ボスの中心座標を算出、設定
        const bossCoordinate = localBossElement.getBoundingClientRect();
        collisionBoss.calcCenter(bossCoordinate);

        // ツインビーの中心座標を算出、設定
        const twinbeeCoordinate = localCharactorElement.getBoundingClientRect();
        collisionTwinbee.calcCenter(twinbeeCoordinate);

        // 周りの弾の中心座標を算出、設定
        const item1Coordinate = localItem1Element.getBoundingClientRect();
        collisionItem1.calcCenter(item1Coordinate);

        const item2Coordinate = localItem2Element.getBoundingClientRect();
        collisionItem2.calcCenter(item2Coordinate);

        const item3Coordinate = localItem3Element.getBoundingClientRect();
        collisionItem3.calcCenter(item3Coordinate);

        const item4Coordinate = localItem4Element.getBoundingClientRect();
        collisionItem4.calcCenter(item4Coordinate);

        const item5Coordinate = localItem5Element.getBoundingClientRect();
        collisionItem5.calcCenter(item5Coordinate);
        const item6Coordinate = localItem6Element.getBoundingClientRect();
        collisionItem6.calcCenter(item6Coordinate);

        // 弾がボスに当たった時の処理
        if (collisionBoss.isHit(collisionBullet)) {
          bullet.initPosition();
          if (bossFlushElement.currentTime >= delay) {
            bossElement.animate(flash.process, flash.setting);
            bossFlushElement.currentTime = 0;
            boss.takeDamage(bullet.getDamage());
            boss.isDead(bossElement);
          }
        }

        // 弾がボAnimationスの周りの玉に当たった時の処理
        if (collisionItem1.isHit(collisionBullet)) {
          bullet.initPosition();
          if (item1FlushElement.currentTime >= delay) {
            item1Element.animate(flash.process, flash.setting);
            item1FlushElement.currentTime = 0;
            item1.takeDamage(bullet.getDamage());
            item1.isDead(item1Element);
          }
        }
        if (collisionItem2.isHit(collisionBullet)) {
          bullet.initPosition();
          if (item2FlushElement.currentTime >= delay) {
            item2Element.animate(flash.process, flash.setting);
            item2FlushElement.currentTime = 0;
            item2.takeDamage(bullet.getDamage());
            item2.isDead(item2Element);
          }
        }
        if (collisionItem3.isHit(collisionBullet)) {
          bullet.initPosition();
          if (item3FlushElement.currentTime >= delay) {
            item3Element.animate(flash.process, flash.setting);
            item3FlushElement.currentTime = 0;
            item3.takeDamage(bullet.getDamage());
            item3.isDead(item3Element);
          }
        }
        if (collisionItem4.isHit(collisionBullet)) {
          bullet.initPosition();
          if (item4FlushElement.currentTime >= delay) {
            item4Element.animate(flash.process, flash.setting);
            item4FlushElement.currentTime = 0;
            item4.takeDamage(bullet.getDamage());
            item4.isDead(item4Element);
          }
        }
        if (collisionItem5.isHit(collisionBullet)) {
          bullet.initPosition();
          if (item5FlushElement.currentTime >= delay) {
            item5Element.animate(flash.process, flash.setting);
            item5FlushElement.currentTime = 0;
            item5.takeDamage(bullet.getDamage());
            item5.isDead(item5Element);
          }
        }
        if (collisionItem6.isHit(collisionBullet)) {
          bullet.initPosition();
          if (item6FlushElement.currentTime >= delay) {
            item6Element.animate(flash.process, flash.setting);
            item6FlushElement.currentTime = 0;
            item6.takeDamage(bullet.getDamage());
            item6.isDead(item6Element);
          }
        }

        // ボスがツインビーに当たった時の処理
        if (
          collisionTwinbee.isHit(collisionBoss) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(boss.getDamage());
          twinbee.isDead(charElement);
        }

        // ボスの周りの玉がツインビーに当たった時の処理
        if (
          collisionItem1.isHit(collisionTwinbee) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(item1.getDamage());
          twinbee.isDead(charElement);
        }
        if (
          collisionItem2.isHit(collisionTwinbee) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(item2.getDamage());
          twinbee.isDead(charElement);
        }
        if (
          collisionItem3.isHit(collisionTwinbee) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(item3.getDamage());
          twinbee.isDead(charElement);
        }
        if (
          collisionItem4.isHit(collisionTwinbee) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(item4.getDamage());
          twinbee.isDead(charElement);
        }
        if (
          collisionItem5.isHit(collisionTwinbee) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(item5.getDamage());
          twinbee.isDead(charElement);
        }
        if (
          collisionItem6.isHit(collisionTwinbee) &&
          twinbeeFlushElement.currentTime >= delay
        ) {
          charElement.animate(flash.process, flash.setting);
          twinbeeFlushElement.currentTime = 0;
          twinbee.takeDamage(item6.getDamage());
          twinbee.isDead(charElement);
        }

        requestAnimationFrame(hit);
      })();

      // ### ボスの移動処理 ###
      (function bossMoveAnimation() {
        if (boss.canMove(fieldCoordinate) && isBossMoving) {
          switch (bossActionPattern) {
            case 0:
              // アニメーションで実装
              boss.changeAnimation(bossElement, "bossMovePattern0 1s linear");
              break;
            case 1:
              boss.changeAnimation(bossElement, "bossMovePattern1 1s linear");
              break;
            case 2:
              boss.changeAnimation(bossElement, "bossMovePattern2 3s linear");
              item1.changeAnimation(
                item1Element,
                "circle-move-spread-anim1 3s linear infinite"
              );
              item2.changeAnimation(
                item2Element,
                "circle-move-spread-anim2 3s linear infinite"
              );
              item3.changeAnimation(
                item3Element,
                "circle-move-spread-anim3 3s linear infinite"
              );
              item4.changeAnimation(
                item4Element,
                "circle-move-spread-anim4 3s linear infinite"
              );
              item5.changeAnimation(
                item5Element,
                "circle-move-spread-anim5 3s linear infinite"
              );
              item6.changeAnimation(
                item6Element,
                "circle-move-spread-anim6 3s linear infinite"
              );
              break;
          }
        } else {
          isBossMoving = false;
        }
        requestAnimationFrame(bossMoveAnimation);
      })();

      window.addEventListener("DOMContentLoaded", () => {
        if (!isBossMoving) {
          // 3秒ごとに実行
          setInterval(() => {
            boss.changeAnimation(bossElement, "");
            item1.changeAnimation(
              item1Element,
              "circle-move-anim1 4s linear infinite"
            );
            item2.changeAnimation(
              item2Element,
              "circle-move-anim2 4s linear infinite"
            );
            item3.changeAnimation(
              item3Element,
              "circle-move-anim3 4s linear infinite"
            );
            item4.changeAnimation(
              item4Element,
              "circle-move-anim4 4s linear infinite"
            );
            item5.changeAnimation(
              item5Element,
              "circle-move-anim5 4s linear infinite"
            );
            item6.changeAnimation(
              item6Element,
              "circle-move-anim6 4s linear infinite"
            );

            // ボスの行動パターンを設定
            bossActionPattern = Math.ceil(Math.random() * 3) - 1;
            isBossMoving = true;
          }, 3000);
        }
      });
    </script>
  </body>
</html>
