<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>キャラクター作成</title>
    <link type="text/css" rel="stylesheet" href="./css/twinbee.css" />
  </head>
  <body>
    <div class="total">
      <div class="bullet"></div>
      <div class="leftArm"></div>
      <div class="rightArm"></div>
      <div class="leftHand"></div>
      <div class="rightHand"></div>
      <div class="body">
        <div class="eye"></div>
        <div class="leftLeg"></div>
        <div class="tail"></div>
        <div class="rightLeg"></div>
      </div>
    </div>
    <div class="boss">
      <div class="item1"></div>
      <div class="item2"></div>
      <div class="item3"></div>
      <div class="item4"></div>
      <div class="item5"></div>
      <div class="item6"></div>
    </div>
    <div class="field"></div>
    <script type="module">
      import { Twinbee } from "./class/twinbee.js";
      import { Key } from "./class/key.js";
      import { Bullet } from "./class/bullet.js";
      import { CollisionDetection } from "./class/collisionDetection.js";
      import { Enemy } from "./class/enemy.js";

      // ### 変数定義 ###
      const charElement = document.getElementsByClassName("total")[0];
      const bulletElement = document.getElementsByClassName("bullet")[0];
      const fieldElement = document.getElementsByClassName("field")[0];
      const bossElement = document.getElementsByClassName("boss")[0];
      const item1Element = document.getElementsByClassName("item1")[0];
      const item2Element = document.getElementsByClassName("item2")[0];
      const item3Element = document.getElementsByClassName("item3")[0];
      const item4Element = document.getElementsByClassName("item4")[0];
      const item5Element = document.getElementsByClassName("item5")[0];
      const item6Element = document.getElementsByClassName("item6")[0];
      // 移動判定用のフィールド座標系
      const fieldCoordinate = fieldElement.getBoundingClientRect();
      let isAttack = 0;
      // ボスの行動パターン
      let bossActionPattern = 0;
      let beforeBossActionPattern = 0;
      // ボスが移動中かどうか判定
      let isBossMoving = false;

      // ### インスタンス生成 ###
      // 各キャラクターインスタンス
      const twinbee = new Twinbee();
      const key = new Key();
      const bullet = new Bullet();
      const boss = new Enemy(40, 30, 1);
      const item1 = new Enemy(20, 0, 1);
      const item2 = new Enemy(20, 0, 1);
      const item3 = new Enemy(20, 0, 1);
      const item4 = new Enemy(20, 0, 1);
      const item5 = new Enemy(20, 0, 1);
      const item6 = new Enemy(20, 0, 1);
      // 当たり判定用インスタンス
      const collisionBullet = new CollisionDetection(
        bulletElement.clientWidth / 2
      );
      const collisionBoss = new CollisionDetection(bossElement.clientWidth / 2);
      const collisionTwinbee = new CollisionDetection(
        charElement.clientWidth / 2
      );
      const collisionItem1 = new CollisionDetection(
        item1Element.clientWidth / 2
      );
      const collisionItem2 = new CollisionDetection(
        item2Element.clientWidth / 2
      );
      const collisionItem3 = new CollisionDetection(
        item3Element.clientWidth / 2
      );
      const collisionItem4 = new CollisionDetection(
        item4Element.clientWidth / 2
      );
      const collisionItem5 = new CollisionDetection(
        item5Element.clientWidth / 2
      );
      const collisionItem6 = new CollisionDetection(
        item6Element.clientWidth / 2
      );

      // ### キー押下処理 ###
      document.addEventListener("keydown", (e) => {
        // 左右キー押下時処理
        if (key.isMoveX(e.key)) {
          twinbee.setDirectionX(key.whichMoveX(e.key));
        }
        // 上下キー押下時処理
        if (key.isMoveY(e.key)) {
          twinbee.setDirectionY(key.whichMoveY(e.key));
        }
        // a(攻撃)キー押下時処理
        if (key.isAttack(e.key)) {
          Object.assign(bulletElement.style, {
            display: "",
          });
          isAttack = 1;
        }
      });

      // ### キー離した処理 ###
      document.addEventListener("keyup", (e) => {
        // 左右キー離したとき処理
        if (twinbee.getDirectionX() === key.whichMoveX(e.key)) {
          twinbee.initDirectionX();
        }
        // 上下キー離したとき処理
        if (twinbee.getDirectionY() === key.whichMoveY(e.key)) {
          twinbee.initDirectionY();
        }
        // a(攻撃)キー離したとき処理
        if (key.isAttack(e.key)) {
          Object.assign(bulletElement.style, {
            display: "none",
          });
          isAttack = 0;
        }
      });

      // ### ツインビー移動の処理 ###
      (function twinbeeMoveAnimation() {
        // スクロールしない範囲での移動に限定させる
        // 後々は移動できる範囲をボックス内に限定させる
        if (twinbee.canMove(fieldCoordinate)) {
          twinbee.move(charElement);
        }

        requestAnimationFrame(twinbeeMoveAnimation);
      })();

      // ### 弾の移動処理 ###
      (function bulletMoveAnimation() {
        bullet.move(bulletElement, isAttack);
        bullet.initPositionWhenOverField(bulletElement);

        requestAnimationFrame(bulletMoveAnimation);
      })();

      // ### 敵を対象とした当たり判定を常時計算 ###
      (function hit() {
        // 当たり判定算出対象の座標を再計算
        const localBulletElement = document.getElementsByClassName("bullet")[0];
        const localBossElement = document.getElementsByClassName("boss")[0];
        const localCharactorElement =
          document.getElementsByClassName("total")[0];
        const localItem1Element = document.getElementsByClassName("item1")[0];
        const localItem2Element = document.getElementsByClassName("item2")[0];
        const localItem3Element = document.getElementsByClassName("item3")[0];
        const localItem4Element = document.getElementsByClassName("item4")[0];
        const localItem5Element = document.getElementsByClassName("item5")[0];
        const localItem6Element = document.getElementsByClassName("item6")[0];

        // 弾の中心座標を算出、設定
        const bulletCoordinate = localBulletElement.getBoundingClientRect();
        collisionBullet.calcCenter(bulletCoordinate);

        // ボスの中心座標を算出、設定
        const bossCoordinate = localBossElement.getBoundingClientRect();
        collisionBoss.calcCenter(bossCoordinate);

        // ツインビーの中心座標を算出、設定
        const twinbeeCoordinate = localCharactorElement.getBoundingClientRect();
        collisionTwinbee.calcCenter(twinbeeCoordinate);

        // 周りの弾の中心座標を算出、設定
        const item1Coordinate = localItem1Element.getBoundingClientRect();
        collisionItem1.calcCenter(item1Coordinate);

        const item2Coordinate = localItem2Element.getBoundingClientRect();
        collisionItem2.calcCenter(item2Coordinate);

        const item3Coordinate = localItem3Element.getBoundingClientRect();
        collisionItem3.calcCenter(item3Coordinate);

        const item4Coordinate = localItem4Element.getBoundingClientRect();
        collisionItem4.calcCenter(item4Coordinate);

        const item5Coordinate = localItem5Element.getBoundingClientRect();
        collisionItem5.calcCenter(item5Coordinate);
        const item6Coordinate = localItem6Element.getBoundingClientRect();
        collisionItem6.calcCenter(item6Coordinate);

        // 弾がボスに当たった時の処理
        if (collisionBoss.isHit(collisionBullet)) {
          bullet.initPosition();
          boss.takeDamage(bullet.getDamage());
          boss.isDead(bossElement);
        }

        // 弾がボスの周りの玉に当たった時の処理
        if (collisionItem1.isHit(collisionBullet)) {
          bullet.initPosition();
          item1.takeDamage(bullet.getDamage());
          item1.isDead(item1Element);
        }
        if (collisionItem2.isHit(collisionBullet)) {
          bullet.initPosition();
          item2.takeDamage(bullet.getDamage());
          item2.isDead(item2Element);
        }
        if (collisionItem3.isHit(collisionBullet)) {
          bullet.initPosition();
          item2.takeDamage(bullet.getDamage());
          item3.isDead(item3Element);
        }
        if (collisionItem4.isHit(collisionBullet)) {
          bullet.initPosition();
          item4.takeDamage(bullet.getDamage());
          item4.isDead(item4Element);
        }
        if (collisionItem5.isHit(collisionBullet)) {
          bullet.initPosition();
          item4.takeDamage(bullet.getDamage());
          item5.isDead(item5Element);
        }
        if (collisionItem6.isHit(collisionBullet)) {
          bullet.initPosition();
          item6.takeDamage(bullet.getDamage());
          item6.isDead(item6Element);
        }

        // ボスがツインビーに当たった時の処理
        if (collisionTwinbee.isHit(collisionBoss)) {
          twinbee.takeDamage(boss.getDamage());
          twinbee.isDead(charElement);
        }

        // ボスの周りの玉がツインビーに当たった時の処理
        if (collisionItem1.isHit(collisionTwinbee)) {
          twinbee.takeDamage(item1.getDamage());
          twinbee.isDead(charElement);
        }
        if (collisionItem2.isHit(collisionTwinbee)) {
          twinbee.takeDamage(item2.getDamage());
          twinbee.isDead(charElement);
        }
        if (collisionItem3.isHit(collisionTwinbee)) {
          twinbee.takeDamage(item3.getDamage());
          twinbee.isDead(charElement);
        }
        if (collisionItem4.isHit(collisionTwinbee)) {
          twinbee.takeDamage(item4.getDamage());
          twinbee.isDead(charElement);
        }
        if (collisionItem5.isHit(collisionTwinbee)) {
          twinbee.takeDamage(item5.getDamage());
          twinbee.isDead(charElement);
        }
        if (collisionItem6.isHit(collisionTwinbee)) {
          twinbee.takeDamage(item6.getDamage());
          twinbee.isDead(charElement);
        }

        requestAnimationFrame(hit);
      })();

      // ### ボスの移動処理 ###
      (function bossMoveAnimation() {
        if (boss.canMove(fieldCoordinate) && isBossMoving) {
          switch (bossActionPattern) {
            case 0:
              // アニメーションで実装
              boss.move(bossElement);
              break;
            case 1:
              // 下方向への直線移動
              boss.setDirectionX(0);
              boss.setDirectionY(1);
              // マージンを取る必要がある
              boss.move(bossElement);
              break;
            case 2:
              item1.changeAnimation(
                item1Element,
                "circle-move-spread-anim1 3s linear infinite"
              );
              item2.changeAnimation(
                item2Element,
                "circle-move-spread-anim2 3s linear infinite"
              );
              item3.changeAnimation(
                item3Element,
                "circle-move-spread-anim3 3s linear infinite"
              );
              item4.changeAnimation(
                item4Element,
                "circle-move-spread-anim4 3s linear infinite"
              );
              item5.changeAnimation(
                item5Element,
                "circle-move-spread-anim5 3s linear infinite"
              );
              item6.changeAnimation(
                item6Element,
                "circle-move-spread-anim6 3s linear infinite"
              );
              break;
          }
        } else {
          isBossMoving = false;
        }
        requestAnimationFrame(bossMoveAnimation);
      })();

      window.addEventListener("DOMContentLoaded", () => {
        if (!isBossMoving) {
          // 3秒ごとに実行
          setInterval(() => {
            // 元の位置に戻るために方向を反転させる
            boss.reverseDierction();

            item1.changeAnimation(
              item1Element,
              "circle-move-anim1 4s linear infinite"
            );
            item2.changeAnimation(
              item2Element,
              "circle-move-anim2 4s linear infinite"
            );
            item3.changeAnimation(
              item3Element,
              "circle-move-anim3 4s linear infinite"
            );
            item4.changeAnimation(
              item4Element,
              "circle-move-anim4 4s linear infinite"
            );
            item5.changeAnimation(
              item5Element,
              "circle-move-anim5 4s linear infinite"
            );
            item6.changeAnimation(
              item6Element,
              "circle-move-anim6 4s linear infinite"
            );

            // ボスの行動パターンを設定
            beforeBossActionPattern = bossActionPattern;
            bossActionPattern = 0;
            if (beforeBossActionPattern === 0)
              bossActionPattern = Math.ceil(Math.random() * 2);
            isBossMoving = true;
            console.log(bossActionPattern);
          }, 3000);
        }
      });
    </script>
  </body>
</html>
